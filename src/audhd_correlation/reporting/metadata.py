"""Report metadata generation

Collects runtime metadata including timestamps, git info, and config snapshots.
"""
from typing import Dict, Optional, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
import subprocess
import json
import sys
import platform


@dataclass
class ReportMetadata:
    """Complete report metadata"""
    # Timestamps
    generation_time: str
    generation_timestamp: float

    # Git information
    git_commit: Optional[str] = None
    git_branch: Optional[str] = None
    git_tag: Optional[str] = None
    git_dirty: bool = False

    # Python environment
    python_version: str = ""
    platform: str = ""

    # Package versions
    package_versions: Dict[str, str] = field(default_factory=dict)

    # Config snapshot
    config_snapshot: Optional[Dict[str, Any]] = None

    # Pipeline execution
    pipeline_version: str = ""
    execution_time_seconds: Optional[float] = None

    # User info (optional)
    generated_by: Optional[str] = None
    institution: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return asdict(self)

    def to_json(self, indent: int = 2) -> str:
        """Convert to JSON string"""
        return json.dumps(self.to_dict(), indent=indent)

    def to_html_section(self) -> str:
        """Generate HTML metadata section"""
        html = '<div class="metadata-section">\n'
        html += '  <h3>Report Metadata</h3>\n'
        html += '  <table class="metadata-table">\n'

        # Generation info
        html += f'    <tr><th>Generated</th><td>{self.generation_time}</td></tr>\n'

        if self.generated_by:
            html += f'    <tr><th>Generated By</th><td>{self.generated_by}</td></tr>\n'

        if self.institution:
            html += f'    <tr><th>Institution</th><td>{self.institution}</td></tr>\n'

        # Pipeline info
        html += f'    <tr><th>Pipeline Version</th><td>{self.pipeline_version}</td></tr>\n'

        if self.execution_time_seconds:
            html += f'    <tr><th>Execution Time</th><td>{self.execution_time_seconds:.1f}s</td></tr>\n'

        # Git info
        if self.git_commit:
            commit_display = self.git_commit[:8]
            if self.git_dirty:
                commit_display += " (modified)"
            html += f'    <tr><th>Git Commit</th><td><code>{commit_display}</code></td></tr>\n'

        if self.git_branch:
            html += f'    <tr><th>Git Branch</th><td><code>{self.git_branch}</code></td></tr>\n'

        if self.git_tag:
            html += f'    <tr><th>Git Tag</th><td><code>{self.git_tag}</code></td></tr>\n'

        # Environment info
        html += f'    <tr><th>Python</th><td>{self.python_version}</td></tr>\n'
        html += f'    <tr><th>Platform</th><td>{self.platform}</td></tr>\n'

        html += '  </table>\n'
        html += '</div>\n'

        return html


def get_git_info() -> Dict[str, Optional[str]]:
    """Get git repository information

    Returns:
        Dictionary with commit, branch, tag, and dirty status

    Note:
        Returns empty values if not in git repository or git not available
    """
    git_info = {
        "commit": None,
        "branch": None,
        "tag": None,
        "dirty": False,
    }

    try:
        # Get commit SHA
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode == 0:
            git_info["commit"] = result.stdout.strip()

        # Get branch
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode == 0:
            git_info["branch"] = result.stdout.strip()

        # Get tag (if on a tag)
        result = subprocess.run(
            ["git", "describe", "--tags", "--exact-match"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode == 0:
            git_info["tag"] = result.stdout.strip()

        # Check if working directory is dirty
        result = subprocess.run(
            ["git", "status", "--porcelain"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode == 0 and result.stdout.strip():
            git_info["dirty"] = True

    except FileNotFoundError:
        # Git not installed
        pass
    except Exception:
        # Other git errors (not in repo, etc.)
        pass

    return git_info


def get_package_versions() -> Dict[str, str]:
    """Get versions of key packages

    Returns:
        Dictionary mapping package names to versions
    """
    versions = {}

    # Core packages to track
    packages = [
        "numpy",
        "pandas",
        "scipy",
        "scikit-learn",
        "matplotlib",
        "seaborn",
        "hdbscan",
        "umap-learn",
        "mofa",
        "hydra-core",
    ]

    for package in packages:
        try:
            # Try importlib.metadata (Python 3.8+)
            from importlib.metadata import version
            versions[package] = version(package)
        except ImportError:
            try:
                # Fallback to pkg_resources
                import pkg_resources
                versions[package] = pkg_resources.get_distribution(package).version
            except Exception:
                versions[package] = "unknown"
        except Exception:
            versions[package] = "not installed"

    return versions


def generate_metadata(
    config: Optional[Any] = None,
    execution_time: Optional[float] = None,
    generated_by: Optional[str] = None,
    institution: Optional[str] = None,
) -> ReportMetadata:
    """Generate complete report metadata

    Args:
        config: Pipeline config object (optional)
        execution_time: Pipeline execution time in seconds (optional)
        generated_by: User or system that generated report (optional)
        institution: Institution name (optional)

    Returns:
        ReportMetadata object with all information
    """
    from .. import __version__

    # Timestamps
    now = datetime.now()
    generation_time = now.strftime("%Y-%m-%d %H:%M:%S")
    generation_timestamp = now.timestamp()

    # Git info
    git_info = get_git_info()

    # Python environment
    python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    platform_str = f"{platform.system()} {platform.release()}"

    # Package versions
    package_versions = get_package_versions()

    # Config snapshot (convert to dict if needed)
    config_snapshot = None
    if config is not None:
        if hasattr(config, "to_dict"):
            config_snapshot = config.to_dict()
        elif hasattr(config, "__dict__"):
            config_snapshot = {
                k: v for k, v in config.__dict__.items()
                if not k.startswith("_")
            }

    return ReportMetadata(
        generation_time=generation_time,
        generation_timestamp=generation_timestamp,
        git_commit=git_info["commit"],
        git_branch=git_info["branch"],
        git_tag=git_info["tag"],
        git_dirty=git_info["dirty"],
        python_version=python_version,
        platform=platform_str,
        package_versions=package_versions,
        config_snapshot=config_snapshot,
        pipeline_version=__version__,
        execution_time_seconds=execution_time,
        generated_by=generated_by,
        institution=institution,
    )


def save_metadata(metadata: ReportMetadata, output_path: str) -> None:
    """Save metadata to JSON file

    Args:
        metadata: ReportMetadata object
        output_path: Output file path
    """
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w") as f:
        f.write(metadata.to_json())


def load_metadata(input_path: str) -> ReportMetadata:
    """Load metadata from JSON file

    Args:
        input_path: Input file path

    Returns:
        ReportMetadata object
    """
    with open(input_path) as f:
        data = json.load(f)

    return ReportMetadata(**data)